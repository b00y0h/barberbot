---
phase: 03-stt-migration
plan: 03
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/services/aws-transcribe-stt.ts
  - src/services/aws-transcribe-stt.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "AWSTranscribeSTT emits utterance_end event after final transcript with silence"
    - "utterance_end triggers natural conversation boundary detection"
    - "CallManager's utterance buffer flushes on utterance_end event (not just timeout)"
  artifacts:
    - path: "src/services/aws-transcribe-stt.ts"
      provides: "utterance_end emission logic"
      contains: "emit('utterance_end')"
    - path: "src/services/aws-transcribe-stt.test.ts"
      provides: "Test verifying utterance_end is emitted"
      contains: "utterance_end"
  key_links:
    - from: "aws-transcribe-stt.ts"
      to: "CallManager utterance_end handler"
      via: "EventEmitter emit"
      pattern: "emit\\('utterance_end'\\)"
---

<objective>
Implement utterance end detection in AWSTranscribeSTT by deriving it from AWS Transcribe's final result timing.

Purpose: AWS Transcribe doesn't have an explicit utterance_end event like Deepgram. We need to synthesize this event by detecting when a final transcript is followed by silence (no new transcripts within a debounce window). This enables natural conversation boundary detection instead of relying solely on CallManager's 700ms timeout fallback.

Output: AWSTranscribeSTT class that emits utterance_end event at natural speech boundaries, matching DeepgramSTT behavior.
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stt-migration/03-VERIFICATION.md
@src/services/aws-transcribe-stt.ts
@src/services/aws-transcribe-stt.test.ts
@src/services/stt.ts (reference: how Deepgram emits utterance_end at line 56-58)
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Add failing test for utterance_end emission</name>
  <files>src/services/aws-transcribe-stt.test.ts</files>
  <action>
Add a new test case in the 'integration behavior' describe block that verifies utterance_end is emitted after receiving a final transcript.

The test should:
1. Create an AWSTranscribeSTT instance
2. Set up a listener for 'utterance_end' event
3. Simulate the internal processing that would trigger utterance_end (we can't easily simulate full AWS response, but we can verify the emission logic works by calling internal methods or by triggering the debounce mechanism)

Since we're testing event emission behavior, structure the test to verify:
- After a final transcript is processed, utterance_end eventually fires
- Use setTimeout or fake timers if needed to verify the debounce behavior

Test name: "emits utterance_end after final transcript with silence"

The test should FAIL initially because the utterance_end emission logic doesn't exist yet.
  </action>
  <verify>npm test -- src/services/aws-transcribe-stt.test.ts - test should fail with utterance_end not being emitted</verify>
  <done>Test exists and fails because utterance_end emission is not implemented</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement utterance_end detection using final result timing</name>
  <files>src/services/aws-transcribe-stt.ts</files>
  <action>
Add utterance end detection logic to processTranscriptStream() method. The strategy:

1. Add private member variable for the debounce timer:
   ```typescript
   private utteranceEndTimer: ReturnType<typeof setTimeout> | null = null;
   ```

2. Replace the empty block at lines 176-181 with actual utterance_end detection:
   - When a final result is received (IsPartial === false && transcript has content):
     - Clear any existing utteranceEndTimer
     - Start a new timer (300ms recommended - matches typical speech pause)
     - When timer fires: emit('utterance_end')

3. Clear the timer in stop() method to prevent memory leaks

4. The debounce approach:
   - Each final result resets the timer
   - Only when no new finals arrive within 300ms do we emit utterance_end
   - This handles rapid-fire final results during continuous speech

Implementation detail: The 300ms debounce is chosen because:
- Deepgram uses utterance_end_ms: 1000 in stt.ts
- CallManager has a 700ms fallback timeout
- 300ms is short enough to feel responsive but long enough to not trigger mid-sentence
  </action>
  <verify>npm test -- src/services/aws-transcribe-stt.test.ts - all tests should pass including the new utterance_end test</verify>
  <done>AWSTranscribeSTT emits utterance_end after final transcripts with silence, test passes</done>
</task>

</tasks>

<verification>
1. grep for emit\('utterance_end'\) in aws-transcribe-stt.ts confirms implementation exists
2. npm test shows all tests pass including utterance_end emission test
3. utteranceEndTimer is properly cleaned up in stop() method
</verification>

<success_criteria>
- AWSTranscribeSTT emits utterance_end event when speech segment ends
- Verification.md gap is closed: "Utterance end detection triggers at natural conversation boundaries" is now satisfied
- Test proves the behavior works without requiring live AWS connection
- STT-02 requirement (utterance/endpoint detection) is now fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/03-stt-migration/03-03-SUMMARY.md`
</output>
