---
phase: 04-tts-migration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/services/aws-polly-tts.ts
  - src/services/aws-polly-tts.test.ts
autonomous: true

must_haves:
  truths:
    - "AWSPollyTTS emits 'audio' events with mulaw Buffer chunks"
    - "AWSPollyTTS emits 'done' event when synthesis completes"
    - "AWSPollyTTS emits 'error' event on API failures"
    - "synthesize() converts text to streaming mulaw audio chunks"
    - "interrupt() aborts in-progress synthesis immediately"
    - "Audio chunks are ~100ms each (800 bytes mulaw at 8kHz)"
  artifacts:
    - path: "src/services/aws-polly-tts.ts"
      provides: "AWSPollyTTS class with EventEmitter interface"
      exports: ["AWSPollyTTS"]
    - path: "src/services/aws-polly-tts.test.ts"
      provides: "Tests for AWSPollyTTS behavior"
      min_lines: 50
  key_links:
    - from: "src/services/aws-polly-tts.ts"
      to: "src/services/aws-clients.ts"
      via: "getPollyClient() import"
      pattern: "getPollyClient"
    - from: "src/services/aws-polly-tts.ts"
      to: "src/services/audio-convert.ts"
      via: "pcmToMulaw() for audio conversion"
      pattern: "pcmToMulaw"
---

<objective>
Create AWSPollyTTS class that wraps Amazon Polly with EventEmitter interface matching current TTSService.

Purpose: Enable drop-in replacement of ElevenLabs/Deepgram TTS with AWS Polly while preserving CallManager integration.

Output: Working AWSPollyTTS class with tests proving EventEmitter compatibility and audio conversion.
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-tts-migration/04-RESEARCH.md

# Required dependencies
@src/services/aws-clients.ts (getPollyClient singleton)
@src/services/audio-convert.ts (pcmToMulaw conversion)
@src/services/tts.ts (current interface to match)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for AWSPollyTTS class</name>
  <files>src/services/aws-polly-tts.test.ts</files>
  <action>
Create test file with tests for:

1. **Class structure**:
   - AWSPollyTTS exists and extends EventEmitter
   - Has synthesize(text: string) method returning Promise<void>
   - Has interrupt() method

2. **Event emission**:
   - Emits 'audio' events with Buffer chunks during synthesis
   - Emits 'done' event after synthesis completes
   - Emits 'error' event on API failure

3. **Audio format**:
   - Audio chunks are Buffer instances (mulaw format)
   - Multiple 'audio' events emitted for longer text (streaming behavior)

4. **Interrupt behavior**:
   - interrupt() stops synthesis (no more audio events after interrupt)
   - Safe to call interrupt() when not synthesizing

Mock Polly using jest.mock('@aws-sdk/client-polly'). Create mock that returns a readable stream of PCM chunks. Verify pcmToMulaw is called via jest.mock('./audio-convert').

Test naming pattern: `describe('AWSPollyTTS', () => { ... })`

Do NOT test actual AWS connectivity - mock all AWS SDK calls.
  </action>
  <verify>npm test -- aws-polly-tts.test.ts runs and shows failing tests (no implementation yet)</verify>
  <done>Test file exists with 8+ tests covering EventEmitter interface, all tests fail</done>
</task>

<task type="auto">
  <name>Task 2: Implement AWSPollyTTS class to pass tests</name>
  <files>src/services/aws-polly-tts.ts</files>
  <action>
Implement AWSPollyTTS class following research patterns:

```typescript
import { SynthesizeSpeechCommand } from '@aws-sdk/client-polly';
import { EventEmitter } from 'events';
import { getPollyClient } from './aws-clients';
import { pcmToMulaw } from './audio-convert';

export class AWSPollyTTS extends EventEmitter {
  private abortController: AbortController | null = null;
  private isRetrying = false;

  async synthesize(text: string): Promise<void> {
    this.abortController = new AbortController();

    try {
      await this.doSynthesize(text);
    } catch (err: any) {
      // One silent retry on transient errors per CONTEXT.md
      if (!this.isRetrying && this.isRetryableError(err)) {
        console.log('[AWS] Polly transient error, retrying once');
        this.isRetrying = true;
        try {
          this.abortController = new AbortController();
          await this.doSynthesize(text);
        } catch (retryErr) {
          this.handleError(retryErr);
        } finally {
          this.isRetrying = false;
        }
      } else {
        this.handleError(err);
      }
    } finally {
      this.emit('done');
    }
  }

  private async doSynthesize(text: string): Promise<void> {
    const pollyClient = getPollyClient();

    const command = new SynthesizeSpeechCommand({
      Engine: 'generative',
      VoiceId: 'Ruth',
      OutputFormat: 'pcm',
      SampleRate: '8000',
      Text: text,
      TextType: 'text',
    });

    const response = await pollyClient.send(command, {
      abortSignal: this.abortController!.signal,
    });

    if (!response.AudioStream) {
      throw new Error('No AudioStream in Polly response');
    }

    // Stream PCM chunks, convert to mulaw, emit
    const stream = response.AudioStream as NodeJS.ReadableStream;
    const CHUNK_SIZE = 1600; // 100ms at 8kHz 16-bit mono PCM
    let buffer = Buffer.alloc(0);

    for await (const chunk of stream) {
      if (this.abortController?.signal.aborted) break;

      buffer = Buffer.concat([buffer, Buffer.from(chunk)]);

      while (buffer.length >= CHUNK_SIZE) {
        const pcmChunk = buffer.subarray(0, CHUNK_SIZE);
        buffer = buffer.subarray(CHUNK_SIZE);

        const mulawChunk = pcmToMulaw(pcmChunk);
        this.emit('audio', mulawChunk);
      }
    }

    // Emit remaining audio
    if (buffer.length >= 2 && !this.abortController?.signal.aborted) {
      const mulawChunk = pcmToMulaw(buffer);
      this.emit('audio', mulawChunk);
    }
  }

  interrupt(): void {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
  }

  private isRetryableError(err: any): boolean {
    // Network errors, throttling, service unavailable
    return err.name === 'ThrottlingException' ||
           err.name === 'ServiceUnavailableException' ||
           err.code === 'ECONNRESET' ||
           err.code === 'ETIMEDOUT';
  }

  private handleError(err: any): void {
    if (err.name === 'AbortError') {
      console.log('[AWS] Polly synthesis interrupted');
      return;
    }
    console.error('[AWS] Polly synthesis failed:', err);
    this.emit('error', err instanceof Error ? err : new Error(String(err)));
  }
}
```

Key implementation details:
- Use generative engine with Ruth voice per CONTEXT.md (best conversational quality)
- Request 8kHz PCM directly from Polly (no resampling needed)
- 1600 byte PCM chunks = 100ms at 8kHz 16-bit mono
- Convert to 800 byte mulaw chunks via pcmToMulaw()
- AbortController for barge-in support
- One silent retry on transient errors (ThrottlingException, ServiceUnavailable)
- [AWS] log prefix per project convention
  </action>
  <verify>npm test -- aws-polly-tts.test.ts shows all tests passing</verify>
  <done>AWSPollyTTS class passes all tests, emits audio/done/error events correctly</done>
</task>

</tasks>

<verification>
Run full TTS test suite:
```bash
npm test -- aws-polly-tts
```

Expected: All tests pass (8+ tests)

Verify class exports correctly:
```bash
npx tsc --noEmit
```

Expected: No TypeScript errors
</verification>

<success_criteria>
1. AWSPollyTTS class exists with EventEmitter interface
2. synthesize() streams audio chunks via 'audio' events
3. interrupt() aborts synthesis via AbortController
4. Error handling with single retry on transient errors
5. All tests pass
6. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-tts-migration/04-01-SUMMARY.md`
</output>
