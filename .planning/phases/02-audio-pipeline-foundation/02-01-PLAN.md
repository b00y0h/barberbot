---
phase: 02-audio-pipeline-foundation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified: [src/services/audio-convert.ts, src/services/audio-convert.test.ts, src/services/tts.ts]
autonomous: true

must_haves:
  truths:
    - "mulaw 8kHz audio converts to PCM16 16-bit samples"
    - "PCM16 audio converts to mulaw 8kHz for Twilio"
    - "Round-trip conversion (mulaw → PCM → mulaw) preserves audio fidelity"
    - "Conversion functions are synchronous and non-blocking"
  artifacts:
    - path: "src/services/audio-convert.ts"
      provides: "Audio conversion utilities"
      exports: ["mulawToPcm", "pcmToMulaw", "resamplePcm"]
    - path: "src/services/audio-convert.test.ts"
      provides: "Round-trip and edge case tests"
      min_lines: 50
  key_links:
    - from: "src/services/audio-convert.test.ts"
      to: "src/services/audio-convert.ts"
      via: "import"
      pattern: "import.*from.*audio-convert"
    - from: "src/services/tts.ts"
      to: "src/services/audio-convert.ts"
      via: "import pcmToMulaw, resamplePcm"
      pattern: "import.*pcmToMulaw.*from.*audio-convert"
---

<objective>
Create a dedicated audio conversion module with bidirectional mulaw/PCM conversion functions using TDD.

Purpose: AWS Transcribe requires PCM input (not mulaw), and Polly outputs PCM (needs mulaw for Twilio). This foundational layer enables STT and TTS migration.

Output: `src/services/audio-convert.ts` with tested conversion functions, refactored `tts.ts` to use shared module.
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/workflows/tdd-execute.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audio-pipeline-foundation/02-CONTEXT.md
@src/services/tts.ts
</context>

<feature>
  <name>Bidirectional mulaw/PCM Audio Conversion</name>
  <files>src/services/audio-convert.ts, src/services/audio-convert.test.ts</files>
  <behavior>
    Audio conversion with these cases:

    1. mulawToPcm(Buffer) -> Buffer
       - Input: mulaw 8-bit samples (1 byte per sample)
       - Output: PCM16 little-endian samples (2 bytes per sample)
       - Output length = input length * 2

    2. pcmToMulaw(Buffer) -> Buffer
       - Input: PCM16 little-endian samples (2 bytes per sample)
       - Output: mulaw 8-bit samples (1 byte per sample)
       - Output length = input length / 2

    3. Round-trip fidelity
       - mulawToPcm(pcmToMulaw(pcm)) ~ pcm (within quantization error)
       - pcmToMulaw(mulawToPcm(mulaw)) = mulaw (exact for valid mulaw)

    4. resamplePcm(Buffer, fromRate, toRate) -> Buffer
       - Linear interpolation resampling
       - Same rate returns input unchanged

    5. Edge cases:
       - Empty buffer returns empty buffer
       - Single sample works correctly
       - Large buffers (10+ seconds of audio) don't block
  </behavior>
  <implementation>
    G.711 mu-law codec:
    - Decode: mulaw byte -> 14-bit linear PCM -> 16-bit PCM
    - Encode: 16-bit PCM -> bias -> compress -> mulaw byte

    Existing pcmToMulaw in tts.ts is correct - extract and add inverse.

    Use lookup table for decode (faster), algorithmic for encode.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: Create test file with round-trip and edge case tests</name>
  <files>src/services/audio-convert.test.ts</files>
  <action>
    Create test file using Node.js built-in test runner (node:test).

    Tests to write (RED phase - all should fail initially):

    1. "mulawToPcm converts mulaw bytes to PCM16 samples"
       - Create known mulaw bytes, verify output is PCM16 buffer
       - Output length should be 2x input length

    2. "pcmToMulaw converts PCM16 samples to mulaw bytes"
       - Create known PCM16 samples, verify output is mulaw buffer
       - Output length should be 0.5x input length

    3. "round-trip mulaw -> PCM -> mulaw is lossless"
       - Generate test mulaw data (e.g., all possible byte values 0-255)
       - Convert to PCM, back to mulaw
       - Result should exactly equal input

    4. "round-trip PCM -> mulaw -> PCM has acceptable quantization error"
       - Create test PCM samples (sine wave or ramp)
       - Convert to mulaw, back to PCM
       - Error should be within 2% (mulaw quantization)

    5. "empty buffer returns empty buffer"
       - mulawToPcm(Buffer.alloc(0)) returns empty
       - pcmToMulaw(Buffer.alloc(0)) returns empty

    6. "resamplePcm same rate returns input unchanged"
       - resamplePcm(buffer, 8000, 8000) === buffer

    7. "resamplePcm 24kHz to 8kHz downsamples correctly"
       - Output length should be 1/3 of input length

    Run with: npx tsx --test src/services/audio-convert.test.ts

    Initially all tests should fail (module doesn't exist yet).
  </action>
  <verify>Test file exists and runs (fails with import error or test failures)</verify>
  <done>Test file created with 7+ test cases, all failing</done>
</task>

<task type="auto">
  <name>Task 2: Implement audio-convert module to pass all tests</name>
  <files>src/services/audio-convert.ts</files>
  <action>
    Create audio-convert.ts with these exports:

    1. mulawToPcm(mulawBuffer: Buffer): Buffer
       - Use lookup table for G.711 mulaw decode
       - For each mulaw byte, output 16-bit PCM sample (LE)

       Decode algorithm:
       - Complement the mulaw byte (~byte)
       - Extract sign (bit 7), exponent (bits 4-6), mantissa (bits 0-3)
       - Compute: sample = ((mantissa << 3) + 0x84) << exponent
       - Apply sign
       - Scale to 16-bit range

    2. pcmToMulaw(pcmBuffer: Buffer): Buffer
       - Extract existing pcmToMulaw from tts.ts (lines 9-35)
       - Already correct implementation

    3. resamplePcm(input: Buffer, fromRate: number, toRate: number): Buffer
       - Extract existing resamplePCM from tts.ts (lines 40-60)
       - Already correct implementation

    Run tests after implementation: npx tsx --test src/services/audio-convert.test.ts
  </action>
  <verify>npx tsx --test src/services/audio-convert.test.ts passes all tests</verify>
  <done>All 7+ tests pass, module exports all three functions</done>
</task>

<task type="auto">
  <name>Task 3: Refactor tts.ts to use shared audio-convert module</name>
  <files>src/services/tts.ts</files>
  <action>
    1. Add import at top:
       import { pcmToMulaw, resamplePcm } from './audio-convert';

    2. Remove the inline pcmToMulaw function (lines ~9-35)

    3. Remove the inline resamplePCM function (lines ~40-60)

    4. Update any calls to use imported functions (resamplePCM -> resamplePcm)

    5. Verify TypeScript compiles: npx tsc --noEmit
  </action>
  <verify>npx tsc --noEmit passes, tts.ts imports from audio-convert</verify>
  <done>tts.ts uses shared audio-convert module, no duplicate code, TypeScript compiles</done>
</task>

</tasks>

<verification>
After all tasks:

1. Run full test suite:
   npx tsx --test src/services/audio-convert.test.ts

2. Verify TypeScript compilation:
   npx tsc --noEmit

3. Check exports:
   node -e "const ac = require('./dist/services/audio-convert'); console.log(Object.keys(ac))"
   Should show: ['mulawToPcm', 'pcmToMulaw', 'resamplePcm']

4. Verify tts.ts refactoring:
   grep -n "import.*audio-convert" src/services/tts.ts
   Should show import line
</verification>

<success_criteria>
- audio-convert.ts exports mulawToPcm, pcmToMulaw, resamplePcm
- All tests pass including round-trip fidelity tests
- tts.ts imports from audio-convert (no inline conversion functions)
- TypeScript compiles without errors
- No blocking operations (all synchronous Buffer operations)
</success_criteria>

<output>
After completion, create `.planning/phases/02-audio-pipeline-foundation/02-01-SUMMARY.md`
</output>
